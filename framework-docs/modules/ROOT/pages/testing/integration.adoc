[[integration-testing]]
= Integration Testing

* goal
  ** integration testing /
    *** 👁️ WITHOUT requiring 👁️
      **** deployment | application server or
      **** -- connecting to -- other enterprise infrastructure
    *** _ExampleOfThingsToTest:_
      **** _Example1:_ correct wiring of your Spring IoC container contexts
      **** _Example2:_ Data access / using JDBC or an ORM tool
* `spring-test`
  ** := Spring Framework module /
    *** first-class support -- for -- integration testing
    *** == classes -- for -- integration testing + Spring container
  ** Check xref:core/beans/dependencies.adoc[section on Dependency Management]
* vs unit tests
  ** slower
* vs equivalent-Selenium tests OR remote tests / -- rely on -- deployment | application server
  ** faster
* annotation-driven support
  ** Check xref:testing/testcontext-framework.adoc[Spring TestContext Framework]


[[integration-testing-goals]]
== Goals of Spring's Integration Testing support

* manage xref:testing/integration.adoc#testing-ctx-management[Spring IoC container caching] between tests.
* provide
  ** xref:testing/integration.adoc#testing-fixture-di[Dependency Injection of test fixture instances].
  ** xref:testing/integration.adoc#testing-tx[transaction management] / -- appropriate to -- integration testing.
* supply xref:testing/integration.adoc#testing-support-classes[Spring-specific base classes] / assist
  developers | writing integration tests.

[[testing-ctx-management]]
=== Context Management & Caching

* Spring TestContext Framework
  ** provides consistent loading of
    *** Spring `ApplicationContext` instances
      **** 👀by default, once it's loaded -> the configured `ApplicationContext` is reused | EACH test 👀
        ***** -> setup cost is incurred ONLY 1! / test suite -> subsequent test execution is MUCH faster
      **** see xref:testing/testcontext-framework/ctx-management.adoc[Context Management]
    *** `WebApplicationContext` instances
    *** caching of those contexts
      **** 👀IMPORTANT👀
        ***** Reason: 🧠 startup time can become an issue,  because the objects instantiated by the Spring container -- take -- time to instantiate 🧠
        ***** _Example:_ project / 50 to 100 Hibernate mapping files -- MIGHT take -- 20" to load the mapping files -> can lead to slower overall test / reduce developer productivity
      **** see xref:testing/testcontext-framework/ctx-management/caching.adoc[Context Caching]

* Test classes -- typically -- declare
  ** array of resource locations for XML or
    *** == those / specified |
      **** `web.xml` or
      **** other configuration files -- for -- production deployments
  ** Groovy configuration metadata
    *** OFTEN | classpath
  ** array of component classes / -- is used to -- configure the application
    *** == those / specified |
      **** `web.xml` or
      **** other configuration files -- for -- production deployments

* "`test suite`"
  ** == ALL tests / run | SAME JVM

* if unlikely case that a test corrupts the application context & requires reloading (_Example:_  modifying a bean definition or the state of an application
object) -> TestContext framework -- can be configured to --
  ** reload the configuration and
  ** rebuild the application context | BEFORE executing the NEXT test

[[testing-fixture-di]]
=== Dependency Injection of Test Fixtures

* | TestContext framework loads your application context, it -- can optionally, via Dependency Injection -- configure instances of your test classes
  ** 👀setting up test fixtures -- by using -- application context's preconfigured beans👀
  ** application contexts -- can be reused ACROSS -- VARIOUS testing scenarios
    *** _Example:_ configuring Spring-managed object graphs, transactional proxies, `DataSource` instances,
    *** NO need to duplicate complex test fixture setup -- for -- individual test cases
  ** see xref:testing/testcontext-framework/fixture-di.adoc[DI of test fixtures + TestContext framework]

* _Example:_ let's have `HibernateTitleRepository` / implements data access logic for a `Title` domain entity -> write
integration tests about
  ** Spring configuration
    *** everything -- related to the -- configuration of the `HibernateTitleRepository` bean correct
  ** Hibernate mapping file configuration
    *** everything mapped correctly, lazy-loading settings
  ** logic of the `HibernateTitleRepository`

[[testing-tx]]
=== Transaction Management

* TODO:
One common issue in tests that access a real database is their effect on the state of the
persistence store. Even when you use a development database, changes to the state may
affect future tests. Also, many operations -- such as inserting or modifying persistent
data -- cannot be performed (or verified) outside of a transaction.

The TestContext framework addresses this issue. By default, the framework creates and
rolls back a transaction for each test. You can write code that can assume the existence
of a transaction. If you call transactionally proxied objects in your tests, they behave
correctly, according to their configured transactional semantics. In addition, if a test
method deletes the contents of selected tables while running within the transaction
managed for the test, the transaction rolls back by default, and the database returns to
its state prior to execution of the test. Transactional support is provided to a test by
using a `PlatformTransactionManager` bean defined in the test's application context.

If you want a transaction to commit (unusual, but occasionally useful when you want a
particular test to populate or modify the database), you can tell the TestContext
framework to cause the transaction to commit instead of roll back by using the
xref:testing/annotations.adoc[`@Commit`] annotation.

See transaction management with the xref:testing/testcontext-framework/tx.adoc[TestContext framework].

[[testing-support-classes]]
=== Support Classes for Integration Testing

The Spring TestContext Framework provides several `abstract` support classes that
simplify the writing of integration tests. These base test classes provide well-defined
hooks into the testing framework as well as convenient instance variables and methods,
which let you access:

* The `ApplicationContext`, for performing explicit bean lookups or testing the state of
  the context as a whole.
* A `JdbcTemplate`, for executing SQL statements to query the database. You can use such
  queries to confirm database state both before and after execution of database-related
  application code, and Spring ensures that such queries run in the scope of the same
  transaction as the application code. When used in conjunction with an ORM tool, be sure
  to avoid xref:testing/testcontext-framework/tx.adoc#testcontext-tx-false-positives[false positives].

In addition, you may want to create your own custom, application-wide superclass with
instance variables and methods specific to your project.

See support classes for the xref:testing/testcontext-framework/support-classes.adoc[TestContext framework].
