[[spring-mvc-test-client]]
= Testing Client Applications

* == client-side tests / test code -- internally uses -- `RestTemplate`
* goal
    ** declare expected requests
    ** provide "`stub`" responses
    ** focus on testing the code | isolation (== WITHOUT running a server)
* `MockRestServiceServer`
    ** == central class for client-side REST tests
    ** `RestTemplate` is used as usual
    ** request are expected
        *** by default, -- based on -- expectations declared
        *** if you set `ignoreExpectOrder` | building the server -> ALL expectations are checked -- to find a -- match / given request == requests are allowed | ANY order
            **** JUST applied | first HTTP request
* _Example:_

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	RestTemplate restTemplate = new RestTemplate();

	MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();
    // expect a request to `/greeting` & want to return 200 response with `text/plain` content
	mockServer.expect(requestTo("/greeting")).andRespond(withSuccess());

	// Test code that uses the above RestTemplate ...

	mockServer.verify();
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	val restTemplate = RestTemplate()

	val mockServer = MockRestServiceServer.bindTo(restTemplate).build()
    // expect a request to `/greeting` & want to return 200 response with `text/plain` content
	mockServer.expect(requestTo("/greeting")).andRespond(withSuccess())

	// Test code that uses the above RestTemplate ...

	mockServer.verify()
----
======

* _Example:_ specify `ignoreExpectOrder`

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	server = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build();
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	server = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build()
----
======

* _Example:_ specify range of expectations / HTTP request -- via -- `expect(ExpectedCount count, RequestMatcher matcher)`
    ** `ignoreExpectOrder` is NOT set == default == requests are expected in order of declaration
        *** order applies ONLY | first of any expected request
[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	RestTemplate restTemplate = new RestTemplate();

	MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();
    // expected order
    // 1. request to
    // 2. another request to "/something" or request to "/somewhere"
    // 3. another request to whatever
	mockServer.expect(times(2), requestTo("/something")).andRespond(withSuccess());
	mockServer.expect(times(3), requestTo("/somewhere")).andRespond(withSuccess());

	// ...

	mockServer.verify();
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	val restTemplate = RestTemplate()

	val mockServer = MockRestServiceServer.bindTo(restTemplate).build()
    // expected order
    // 1. request to
    // 2. another request to "/something" or request to "/somewhere"
    // 3. another request to whatever
	mockServer.expect(times(2), requestTo("/something")).andRespond(withSuccess())
	mockServer.expect(times(3), requestTo("/somewhere")).andRespond(withSuccess())

	// ...

	mockServer.verify()
----
======

* TODO:
As an alternative to all of the above, the client-side test support also provides a
`ClientHttpRequestFactory` implementation that you can configure into a `RestTemplate` to
bind it to a `MockMvc` instance. That allows processing requests using actual server-side
logic but without running a server. The following example shows how to do so:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
	this.restTemplate = new RestTemplate(new MockMvcClientHttpRequestFactory(mockMvc));

	// Test code that uses the above RestTemplate ...
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	val mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build()
	restTemplate = RestTemplate(MockMvcClientHttpRequestFactory(mockMvc))

	// Test code that uses the above RestTemplate ...
----
======

In some cases it may be necessary to perform an actual call to a remote service instead
of mocking the response. The following example shows how to do that through
`ExecutingResponseCreator`:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	RestTemplate restTemplate = new RestTemplate();

	// Create ExecutingResponseCreator with the original request factory
	ExecutingResponseCreator withActualResponse = new ExecutingResponseCreator(restTemplate.getRequestFactory());

	MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();
	mockServer.expect(requestTo("/profile")).andRespond(withSuccess());
	mockServer.expect(requestTo("/quoteOfTheDay")).andRespond(withActualResponse);

	// Test code that uses the above RestTemplate ...

	mockServer.verify();
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	val restTemplate = RestTemplate()

	// Create ExecutingResponseCreator with the original request factory
	val withActualResponse = new ExecutingResponseCreator(restTemplate.getRequestFactory())

	val mockServer = MockRestServiceServer.bindTo(restTemplate).build()
	mockServer.expect(requestTo("/profile")).andRespond(withSuccess())
	mockServer.expect(requestTo("/quoteOfTheDay")).andRespond(withActualResponse)

	// Test code that uses the above RestTemplate ...

	mockServer.verify()
----
======

In the preceding example, we create the `ExecutingResponseCreator` using the
`ClientHttpRequestFactory` from the `RestTemplate` _before_ `MockRestServiceServer` replaces
it with a different one that mocks responses.
Then we define expectations with two kinds of responses:

 * a stub `200` response for the `/profile` endpoint (no actual request will be executed)
 * a response obtained through a call to the `/quoteOfTheDay` endpoint

In the second case, the request is executed through the `ClientHttpRequestFactory` that was
captured earlier. This generates a response that could e.g. come from an actual remote server,
depending on how the `RestTemplate` was originally configured.

[[spring-mvc-test-client-static-imports]]
== Static Imports

As with server-side tests, the fluent API for client-side tests requires a few static
imports. Those are easy to find by searching for `MockRest*`. Eclipse users should add
`MockRestRequestMatchers.{asterisk}` and `MockRestResponseCreators.{asterisk}` as
"`favorite static members`" in the Eclipse preferences under Java -> Editor -> Content
Assist -> Favorites. That allows using content assist after typing the first character of
the static method name. Other IDEs (such IntelliJ) may not require any additional
configuration. Check for the support for code completion on static members.

[[spring-mvc-test-client-resources]]
== Further Examples of Client-side REST Tests

Spring MVC Test's own tests include
{spring-framework-code}/spring-test/src/test/java/org/springframework/test/web/client/samples[example
tests] of client-side REST tests.
