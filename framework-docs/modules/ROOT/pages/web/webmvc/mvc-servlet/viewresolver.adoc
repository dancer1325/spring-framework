[[mvc-viewresolver]]
= View Resolution

* [.small]#xref:web/webflux/dispatcher-handler.adoc#webflux-viewresolution[== in the Reactive stack]#

* `ViewResolver` and `View`
  ** := interfaces in Spring MVC /
    *** models in a browser / üëÅÔ∏è NOT tied to a specific view technology üëÅÔ∏è -- can be -- rendered
    *** `ViewResolver`
      **** provides
        ***** mapping between view names -- actual views
      **** ViewResolver implementations

[[mvc-view-resolvers-tbl]]
// TODO:

.ViewResolver implementations
|===
| ViewResolver| Description

| `AbstractCachingViewResolver`
| - some of their subclasses -- cache -- view instances / they resolve +
&#160; &#160; - caching / certain view technologies -> improve performance  +
&#160; &#160; - `cache=false` -> turn off the cache +
&#160; &#160; - if you must refresh certain view at runtime (_Example:_ FreeMarker template is modified) -> use `removeFromCache(String viewName, Locale loc)`

| `UrlBasedViewResolver`
| - := simple implementation of the `ViewResolver` interface / +
&#160; &#160; - üëÅÔ∏è logical view names -- are resolved directly (== without an explicit mapping) -- to URLs üëÅÔ∏è +
  - uses +
&#160; &#160; - logical names -- match straightforward (== without mappings) -- view resources names

| `InternalResourceViewResolver`
| - := subclass of `UrlBasedViewResolver` / supports +
&#160; &#160; - `InternalResourceView` (== Servlets and JSPs) +
&#160; &#160; - subclasses such as `JstlView` +
- `setViewClass(..)`  specify the view class / ALL views -- generated by -- this resolver +
- Check {spring-framework-api}/web/reactive/result/view/UrlBasedViewResolver.html[`UrlBasedViewResolver`]

| `FreeMarkerViewResolver`
| - := subclass of `UrlBasedViewResolver` / supports +
&#160; &#160; - `FreeMarkerView` +
&#160; &#160; - custom subclasses of them

| `ContentNegotiatingViewResolver`
| - := implementation of the `ViewResolver` interface / +
&#160; &#160; - based on the request file name or `Accept` header -> resolves a view +
- Check xref:web/webmvc/mvc-servlet/viewresolver.adoc#mvc-multiple-representations[Content Negotiation]

| `BeanNameViewResolver`
| - := implementation of the `ViewResolver` interface / +
&#160; &#160; - view name -- is interpreted as a -- bean name in the current application context +
&#160; &#160; &#160; &#160; - == each `View` -- can be defined as -- a bean (_Example:_ in XML or in configuration classes) +
&#160; &#160; - very flexible variant -> +
&#160; &#160; &#160; &#160; - based on distinct view names -> different view types -- can be -- mixed and matched

|===

    *** `View`
      **** data -- is prepared before -- handing over to a specific view technology

[[mvc-viewresolver-handling]]
== Handling
[.small]#xref:web/webflux/dispatcher-handler.adoc#webflux-viewresolution-handling[See equivalent in the Reactive stack]#

You can chain view resolvers by declaring more than one resolver bean and, if necessary, by
setting the `order` property to specify ordering. Remember, the higher the order property,
the later the view resolver is positioned in the chain.

The contract of a `ViewResolver` specifies that it can return null to indicate that the
view could not be found. However, in the case of JSPs and `InternalResourceViewResolver`,
the only way to figure out if a JSP exists is to perform a dispatch through
`RequestDispatcher`. Therefore, you must always configure an `InternalResourceViewResolver`
to be last in the overall order of view resolvers.

Configuring view resolution is as simple as adding `ViewResolver` beans to your Spring
configuration. The xref:web/webmvc/mvc-config.adoc[MVC Config] provides a dedicated configuration API for
xref:web/webmvc/mvc-config/view-resolvers.adoc[View Resolvers] and for adding logic-less
xref:web/webmvc/mvc-config/view-controller.adoc[View Controllers] which are useful for HTML template
rendering without controller logic.


[[mvc-redirecting-redirect-prefix]]
== Redirecting
* [.small]#xref:web/webflux/dispatcher-handler.adoc#webflux-redirecting-redirect-prefix[== in the Reactive stack]#

* `redirect:`
    ** := prefix in a view name /
        *** lets you perform a redirect
            **** redirect behavior == controller returned a `RedirectView` / üëÅÔ∏è allows using logical view name üëÅÔ∏è
                ***** _Example1:_ let's a logical view name `redirect:/myapp/some/resource` -> redirects üëÅÔ∏è relative to the current Servlet context üëÅÔ∏è
                ***** _Example2:_ let's a name `redirect:https://myhost.com/some/arbitrary/path` -> redirects to an absolute URL
    ** üëÅÔ∏è if you use `UrlBasedViewResolver` OR its subclasses -> redirect is needed üëÅÔ∏è
    ** viewName == `redirect:URLToRedirect`

[[mvc-redirecting-forward-prefix]]
== Forwarding

You can also use a special `forward:` prefix for view names that are
ultimately resolved by `UrlBasedViewResolver` and subclasses. This creates an
`InternalResourceView`, which does a `RequestDispatcher.forward()`.
Therefore, this prefix is not useful with `InternalResourceViewResolver` and
`InternalResourceView` (for JSPs), but it can be helpful if you use another view
technology but still want to force a forward of a resource to be handled by the
Servlet/JSP engine. Note that you may also chain multiple view resolvers, instead.


[[mvc-multiple-representations]]
== Content Negotiation
[.small]#xref:web/webflux/dispatcher-handler.adoc#webflux-multiple-representations[See equivalent in the Reactive stack]#

{spring-framework-api}/web/servlet/view/ContentNegotiatingViewResolver.html[`ContentNegotiatingViewResolver`]
does not resolve views itself but rather delegates
to other view resolvers and selects the view that resembles the representation requested
by the client. The representation can be determined from the `Accept` header or from a
query parameter (for example, `"/path?format=pdf"`).

The `ContentNegotiatingViewResolver` selects an appropriate `View` to handle the request
by comparing the request media types with the media type (also known as
`Content-Type`) supported by the `View` associated with each of its `ViewResolvers`. The
first `View` in the list that has a compatible `Content-Type` returns the representation
to the client. If a compatible view cannot be supplied by the `ViewResolver` chain,
the list of views specified through the `DefaultViews` property is consulted. This
latter option is appropriate for singleton `Views` that can render an appropriate
representation of the current resource regardless of the logical view name. The `Accept`
header can include wildcards (for example `text/{asterisk}`), in which case a `View` whose
`Content-Type` is `text/xml` is a compatible match.

See xref:web/webmvc/mvc-config/view-resolvers.adoc[View Resolvers] under xref:web/webmvc/mvc-config.adoc[MVC Config] for configuration details.



